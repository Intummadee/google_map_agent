# 1Ô∏è‚É£ ‡∏™‡πà‡∏ß‡∏ô Import Library
import folium
import streamlit as st
import random
import heapq
import json
import time
import streamlit.components.v1 as components
import math

import osmnx as ox
import networkx as nx

from geopy.distance import geodesic 

from function_2.cbs_alogo import *
from app import * 




def find_route_osm(road, start_latlon, end_latlon, algorithm, exclude_pos=None):
    """
    ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏≠‡∏á‡∏à‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡πÇ‡∏Ñ‡∏£‡∏á‡∏Ç‡πà‡∏≤‡∏¢‡∏ñ‡∏ô‡∏ô OSM
    
    Args:
        road: ‡∏Å‡∏£‡∏≤‡∏ü‡πÇ‡∏Ñ‡∏£‡∏á‡∏Ç‡πà‡∏≤‡∏¢‡∏ñ‡∏ô‡∏ô OSM
        start_latlon: ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö (lat, lon)
        end_latlon: ‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö (lat, lon)
        algorithm: ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ ('a_star' ‡∏´‡∏£‡∏∑‡∏≠ 'cbs')
        
    Returns:
        ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏Å‡∏±‡∏î [(lat, lon), ...] ‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
    """
    # ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î latitude, longitude ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Å‡∏£‡∏≤‡∏ü‡∏ñ‡∏ô‡∏ô
    start_node = ox.distance.nearest_nodes(road, start_latlon[1], start_latlon[0])
    end_node = ox.distance.nearest_nodes(road, end_latlon[1], end_latlon[0])
    
    # ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ä‡πâ ox.distance.nearest_nodes ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡∏´‡∏≤‡∏Å‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏°‡∏à‡∏£‡∏¥‡∏á
    if not nx.has_path(road, start_node, end_node):
        print(f"‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start_latlon} ‡πÅ‡∏•‡∏∞ {end_latlon}")
        return [start_latlon, end_latlon]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á

    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏û‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if start_node is None or end_node is None:
        print(f"‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏ñ‡∏ô‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏Å‡∏•‡πâ {start_latlon} ‡∏´‡∏£‡∏∑‡∏≠ {end_latlon}")
        return [start_latlon, end_latlon]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á
    

    # # ‡∏≠‡∏±‡∏•‡∏Å‡∏≠ M* :‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á (exclude_pos) ‡πÉ‡∏´‡πâ‡∏•‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
    # if exclude_pos:
    #     exclude_node = ox.distance.nearest_nodes(road, exclude_pos[1], exclude_pos[0])
    #     if exclude_node in road:
    #         print(f"‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ä‡∏ô‡∏Å‡∏±‡∏ô: {exclude_pos} (‡πÇ‡∏´‡∏ô‡∏î: {exclude_node})")
    #         road.remove_node(exclude_node)  # ‡∏•‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏£‡∏≤‡∏ü‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß


    def get_edge_weight(current, neighbor):
        """
        ‡∏î‡∏∂‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÇ‡∏´‡∏ô‡∏î current ‡πÅ‡∏•‡∏∞ neighbor
        """
        edge_data = road.get_edge_data(current, neighbor)
        if edge_data:
            if isinstance(edge_data, dict):
                return edge_data.get('length', 1)
            elif isinstance(edge_data, list):
                return edge_data[0].get('length', 1)
        return 1  # Default weight if no length found
          

    # ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô
    route_nodes = []

    # üìå ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ò‡∏∂‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
    if algorithm == 'a_star':
        # Use A* algorithm
        try:
            route_nodes = nx.astar_path(road, start_node, end_node, weight='length')
        except nx.NetworkXNoPath:
            print(f"A*: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start_latlon} ‡πÅ‡∏•‡∏∞ {end_latlon}")
            return [start_latlon, end_latlon]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á
        except Exception as e:
            print(f"A*: ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á: {e}")
            return [start_latlon, end_latlon]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á
            
    elif algorithm == 'cbs':
        # Use CBS-specific pathfinding
        try:
            # Initialize priority queue with starting node
            open_set = [(0, start_node)]
            came_from = {}
            g_score = {node: float('inf') for node in road.nodes}
            g_score[start_node] = 0
            
            while open_set:
                current_cost, current = heapq.heappop(open_set)
                
                if current == end_node:
                    # Reconstruct path
                    path = []
                    while current in came_from:
                        path.append(current)
                        current = came_from[current]
                    path.append(start_node)
                    route_nodes = path[::-1]
                    break
                    
                for neighbor in road.neighbors(current):
                    # Get edge weight using helper function
                    weight = get_edge_weight(current, neighbor)
                    
                    tentative_g_score = g_score[current] + weight
                    if tentative_g_score < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g_score
                        f_score = tentative_g_score + heuristic(
                            (road.nodes[neighbor]['y'], road.nodes[neighbor]['x']),
                            end_latlon
                        )
                        heapq.heappush(open_set, (f_score, neighbor))
            else:
                print(f"CBS: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start_latlon} ‡πÅ‡∏•‡∏∞ {end_latlon}")
                return [start_latlon, end_latlon]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á
        
        except Exception as e:
            print(f"CBS: ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á: {e}")
            return [start_latlon, end_latlon]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á
    
    elif algorithm == 'm_star':
        # ‡πÉ‡∏ä‡πâ M* Algorithm
        try:
            # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ A* ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
            route_nodes = nx.astar_path(road, start_node, end_node, weight='length')
            
            # ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á (exclude_pos) ‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
            if exclude_pos:
                # ‡∏´‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ö exclude_pos ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                exclude_node = find_nearest_node_M_Star(road, exclude_pos)
                
                if exclude_node in route_nodes:
                    # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á exclude_node
                    new_path = []
                    for node in route_nodes:
                        if node != exclude_node:
                            new_path.append(node)
                        else:
                            # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡πâ‡∏≠‡∏°
                            try:
                                # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á
                                temp_graph = road.copy()
                                temp_graph.remove_node(exclude_node)
                                
                                # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
                                bypass_path = nx.astar_path(temp_graph, new_path[-1], end_node, weight='length')
                                new_path.extend(bypass_path[1:])
                                break
                            except nx.NetworkXNoPath:
                                print(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡πâ‡∏≠‡∏°‡πÑ‡∏î‡πâ")
                                # ‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°
                                new_path = route_nodes
                                break
                            except Exception as e:
                                print(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡πâ‡∏≠‡∏°: {e}")
                                new_path = route_nodes
                                break
                    
                    route_nodes = new_path
        except nx.NetworkXNoPath:
            print(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start_node} ‡πÅ‡∏•‡∏∞ {end_node} ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ M*")
        except Exception as e:
            print(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢ M*: {e}")
    
    # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á
    if not route_nodes:
        print(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start_latlon} ‡πÅ‡∏•‡∏∞ {end_latlon}")
        return [start_latlon, end_latlon]
    
    # ‡πÅ‡∏õ‡∏•‡∏á‡πÇ‡∏´‡∏ô‡∏î‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î lat, lon
    route_coords = []
    for node in route_nodes:
        # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î
        node_data = road.nodes[node]
        lat = node_data.get('y')  # latitude
        lon = node_data.get('x')  # longitude
        if lat is not None and lon is not None:
            route_coords.append((lat, lon))
    
    # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤ (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ñ‡∏π‡∏Å‡∏î‡∏∂‡∏á‡∏≠‡∏≠‡∏Å‡∏°‡∏≤) ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á
    if not route_coords:
        print(f"‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start_latlon} ‡πÅ‡∏•‡∏∞ {end_latlon}")
        return [start_latlon, end_latlon]
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
    if geodesic(route_coords[0], start_latlon).meters > 10:  # ‡∏´‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÅ‡∏£‡∏Å‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 10 ‡πÄ‡∏°‡∏ï‡∏£
        route_coords.insert(0, start_latlon)
    if geodesic(route_coords[-1], end_latlon).meters > 10:  # ‡∏´‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 10 ‡πÄ‡∏°‡∏ï‡∏£
        route_coords.append(end_latlon)
    
    return route_coords



def find_nearest_node_M_Star(graph, point):
    """
    ‡∏´‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏ô‡∏Å‡∏£‡∏≤‡∏ü‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ö‡∏à‡∏∏‡∏î GPS ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    """
    nodes = list(graph.nodes(data=True))
    nearest_node = None
    min_distance = float('inf')
    
    for node_id, data in nodes:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• lat, lon ‡∏´‡∏£‡∏∑‡∏≠ y, x
        if 'y' in data and 'x' in data:
            node_point = (data['y'], data['x'])
        else:
            # ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏¥‡∏Å‡∏±‡∏î ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°
            continue
        
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î
        distance = geodesic(point, node_point).kilometers
        
        if distance < min_distance:
            min_distance = distance
            nearest_node = node_id
    
    print(f"‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {point}: ‡∏û‡∏ö {nearest_node} ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á {min_distance:.4f} ‡∏Å‡∏°.")
    return nearest_node